Provides a nice API for cassandra backed storage:

class Customer < CassandraObject::Base

  key do 
    rand(2**63).to_s
  end

  attribute :first_name, :type=>String
  attribute :last_name,  :type=>String
  attribute :screen_name, :type=>String
  
  # Timestamps can eventually use the internal per-column stamps
  attribute :created_at,  :type=>Date
  
  before_save :something
  after_save :something_else
  
  # Implies :through => :CustomerAssociations, :super_column_name => "invoices", :class_name => "Invoice"
  # Created an after_destroy to clobber the CustomerAssociations row
  association :to => :invoices

  # Implies :through => :ScreenNameCustomer
  # This makes a row in a bridge CF: self.screen_name => {'id' => self.id}, and 
  # defines a finder Customer.find_by_screen_name()
  # For non-unique compound keys must be used
  index :screen_name, :unique => true
  
  validate :some_validation
end

class Invoice < CassandraObject::Base

  # Requires you to pass a Customer instance and a number at .create
  # Hell on earth if the natural components changes
  key [Customer, Integer] 

  # Opaque JSON object
  attribute :lines, :type=>JSON 
  attribute :date,  :type=>Date
  
  before_save :something
  after_save :something_else
  
  # Implies :through => :CustomerAssociations, :super_column_name => "invoices", :class_name => "Customer" 
  # Creates an after save hook to insert
  association :from => :customers do |parent_id|
    # Return the customer keys to insert self.id into; in this case we get them from 
    # whatever was available to some kind of attacher method
    #   @customer.invoices.create()
    # but it could be arbitrary.
    #
    # With double sided indexes you can also make after_destroy in either side remove 
    # entries properly. Without them, you have to do read-repairs if you hit a record
    # on the parent side that doesn't exist anymore.
    [parent_id] 
  end  
  
  validate :some_validation
end
